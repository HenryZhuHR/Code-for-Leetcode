# 🧮 算法
- [🧮 算法](#-算法)
  - [🏊 回溯算法](#-回溯算法)
  - [🍪 贪心算法](#-贪心算法)
  - [🎒 动态规划](#-动态规划)
    - [状态转移公式](#状态转移公式)
    - [动态规划：背包问题](#动态规划背包问题)
    - [01 背包](#01-背包)

## 🏊 回溯算法

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。<sup>[[代码随想录]](https://programmercarl.com/回溯算法理论基础.html#理论基础)</sup>
- 回溯是**递归**的副产品，只要有递归就会有回溯。
- 回溯法并**不是什么高效的算法**。回溯的**本质是穷举**，类似暴力搜索(brute force, BF)，想让回溯法高效一些，可以加一些剪枝的操作。
- 回溯法，一般可以解决如下几种问题：
  - **组合问题**：N个数里面按一定规则找出k个数的集合。 **(组合无序)**
  - **切割问题**：一个字符串按一定规则有几种切割方式
  - **子集问题**：一个N个数的集合里有多少符合条件的子集
  - **排列问题**：N个数按一定规则全排列，有几种排列方式 **(排列有序)**
  - **棋盘问题**：N皇后，解数独等等
- **回溯法解决的问题都可以抽象为树形结构 (深度优先遍历 DSF)**。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

![回溯搜索过程](./images/algorithm-backtracking-search_process.png)

回溯算法模板框架
```cpp
void backtracking(参数) {
    if (剪枝条件) {
        return;
    }
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```


## 🍪 贪心算法


贪心的本质是**选择每一阶段的局部最优，从而达到全局最优**。步骤：
- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

## 🎒 动态规划

**动态规划 (Dynamic Programming, DP)** ，如果某一问题**有很多重叠子问题**，使用动态规划是最有效的。

所以动态规划中**每一个状态一定是由上一个状态推导出来的**，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

- 动规 是**由前一个状态推导出来的**
- 贪心 是**局部直接选最优的**




### 状态转移公式
### 动态规划：背包问题

![dp-backpack](images/algorithm-dp-backpack.png)

至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。

而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。

所以背包问题的理论基础重中之重是01背包，一定要理解透！

### 01 背包

有 `n` 件物品和一个最多能背重量为 `w` 的背包。第 `i` 件物品的重量是 `weight[i]` ，价值是 `value[i]`  。每件物品只能用一次，求解将哪些物品装入背包里物品**价值总和最大**。

![Alt text](https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png)

1. **二维数组**。 `dp[i][j]` 表示从下标为 `[0-i]` 的物品里任意取，放进容量为 `j` 的背包 (一直递推到 `w` )，价值总和最大是多少。
  - 那么可以有两个方向推出来 `dp[i][j]` ，
  - **不放物品 `i`**：由 `dp[i-1][j]` 推出，即背包容量为 `j` ，里面不放物品 `i` 的最大价值，此时 `dp[i][j]` 就是 `dp[i-1][j]` 。(**其实就是当物品 `i` 的重量大于背包 `j` 的重量时，物品 `i` 无法放进背包中，所以背包内的价值依然和前面相同。**)
  - **放物品 `i`**：由 `dp[i-][j-weight[i]]` 推出，`dp[i-1][j-weight[i]]` 为背包容量为 `j-weight[i]` 的时候不放物品 `i` 的最大价值，那么 `dp[i-][j-weight[i]]+value[i]` （物品 `i` 的价值），就是背包放物品 `i` 得到的最大价值
  - 所以递归公式：
```cpp
dp[i][j]=max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
```
  - 可以看出 `i` 是由 `i-1` 推导出来，那么 `i=0` 的时候就一定要初始化。
  - 因为用到 `i-1` ，所以必须倒叙遍历 i 

```cpp
for(int i = 1; i < weight.size(); i++) { // 遍历物品
for(int j = 0; j <= bagweight; j++) {    // 遍历背包容量
  if (j < weight[i])        // 如果背包容量小于物品重量，
    dp[i][j] = dp[i-1][j];  // 那么物品i无法放进背包中，直接复制上一层
  else                      // 否则，就要考虑放入物品i的情况
    dp[i][j] = max(
      dp[i-1][j],                     // 不放
      dp[i-1][j-weight[i]] + value[i] // 放入
      // 放进去的话，考虑上一层背包容量减去物品i的重量，加上物品i的价值
    );

}
}
```

1. **滚动数组**。 


上面的递推公式可以优化： 其实可以发现如果把 `dp[i-1]` 那一层拷贝到 `dp[i]` 上，表达式完全可以是：
```cpp
dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);
```
- dp 数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。
- 遍历的时候一定需要**倒序**，因为二维数组用到 `i-1` ，所以必须倒叙遍历背包，不然 `i-1` 会被覆盖

> 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！    
> 
> 可以参考 [“背包问题（01背包+滚动数组+完全背包）”](https://zhuanlan.zhihu.com/p/540378850)，考虑 `j` 和 `2j` 的递推: `dp[ j] = max(dp[ j], dp[ j-weight[i]]+value[i]);`：
```cpp
dp[ j] = max(dp[ j], dp[ j - weight[i]] + value[i]);
dp[2j] = max(dp[2j], dp[2j - weight[i]] + value[i]);

// 当 j = weight[i] 这个特殊情况
dp[ j] = max(dp[ j], dp[0] + value[i]);
dp[2j] = max(dp[2j], dp[j] + value[i]);
// 可以看到， weight[i] 被重复放进了两次
```

```cpp
vector<int> dp(bagWeight + 1, 0);
for(int i = 0; i < weight.size(); i++) {      // 遍历物品
for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量(倒序)
    dp[j] = max(
      dp[j],                       // 不放
      dp[j - weight[i]] + value[i] // 放入
    );

    // 如果求方案和，那么就把不放和放的加起来
    // dp[j] = dp[j] + dp[j - weight[i]] (+ value[i]);
}
}
```


01 背包中组合数问题

```cpp
/**
 * 当 1≤i≤n时，对于数组 nums 中的第 i，遍历 0≤j≤neg，计算 dp[i][j]：
 * 如果 j<num，则不能选 num，  此时有 dp[i][j]=dp[i-1][j]；
 * 如果 j≥num，
 *  - 不选  num 方案数是 dp[i-1][j]
 *  - 选    num 方案数是 dp[i-1][j-num]，
 * 此时有 dp[i][j] = dp[i-1][j] + dp[i-1][j-num]
 *
 * 装满背包有几种方法的递推公式
 */
dp[j] = dp[j] + dp[j - nums[i]];

/**
 * 表示 已经 有 nums[i] 时，有 dp[j - nums[i]] 种方法凑成 j
 * 例如：dp[j]，j 为5，
 * nums[i] = 1 , 有 dp[5-1] = dp[4] 种方法凑成 5
 * nums[i] = 2 , 有 dp[5-2] = dp[3] 种方法凑成 5
 * ...
 * dp[j] 定义就是凑成和为 j 有多少种方案
 * 初始为 dp[0] = 1 ，因为不取任何数，和就是 0 (唯一方案)
 */
```


